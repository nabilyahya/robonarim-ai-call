<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OpenAI Realtime Voice Test</title>
    <style>
      body {
        font-family: system-ui, Arial;
        max-width: 980px;
        margin: 24px auto;
        padding: 0 12px;
      }
      .row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }
      select,
      button,
      input,
      textarea {
        padding: 10px 12px;
        font-size: 14px;
      }
      button {
        cursor: pointer;
      }
      textarea {
        width: 100%;
        min-height: 110px;
      }
      pre {
        background: #0b0b0b;
        color: #ddd;
        padding: 12px;
        border-radius: 10px;
        overflow: auto;
      }
      .card {
        border: 1px solid #ddd;
        border-radius: 12px;
        padding: 12px;
        margin-top: 12px;
      }
      .muted {
        color: #555;
        font-size: 13px;
      }
      audio {
        width: 100%;
        margin-top: 8px;
      }
    </style>
  </head>
  <body>
    <h2>OpenAI Realtime Voice Test (WebRTC)</h2>
    <p class="muted">
      Connect -> ÙŠØ³Ù…Ø­ Ù„Ù„Ù…Ø§ÙŠÙƒ -> ØªØ³Ù…Ø¹ ØµÙˆØª Ø§Ù„Ù…ÙˆØ¯ÙŠÙ„ Ù‡Ù†Ø§. Ø¥Ø°Ø§ Ø¨Ø¯Ùƒ ØªØºÙŠÙ‘Ø± Ø§Ù„Ù€ voice
      Ù„Ø§Ø²Ù… Disconnect Ø«Ù… Connect (Ù„Ø£Ù† Ø§Ù„Ù€ voice Ù…Ø§ Ø¨ÙŠØªØºÙŠØ± Ø¨Ø¹Ø¯ Ø£ÙˆÙ„ ØµÙˆØª).
    </p>

    <div class="card">
      <div class="row">
        <label>
          Model:
          <select id="modelSelect"></select>
        </label>

        <label>
          Voice:
          <select id="voiceSelect"></select>
        </label>

        <button id="connectBtn">Connect</button>
        <button id="disconnectBtn" disabled>Disconnect</button>
      </div>

      <div style="margin-top: 10px">
        <label>First message (optional, sent once after connect):</label>
        <textarea id="firstMsg">
Merhaba! Robonarim teknik servis. Size nasÄ±l yardÄ±mcÄ± olabilirim?</textarea
        >
        <div class="row">
          <button id="sendFirstBtn" disabled>Send first message</button>
        </div>
      </div>

      <audio id="remoteAudio" autoplay></audio>
      <pre id="log"></pre>
    </div>

    <script>
      const logEl = document.getElementById("log");
      const modelSelect = document.getElementById("modelSelect");
      const voiceSelect = document.getElementById("voiceSelect");
      const connectBtn = document.getElementById("connectBtn");
      const disconnectBtn = document.getElementById("disconnectBtn");
      const sendFirstBtn = document.getElementById("sendFirstBtn");
      const firstMsgEl = document.getElementById("firstMsg");
      const remoteAudio = document.getElementById("remoteAudio");

      function log(...args) {
        const line = args
          .map((a) => (typeof a === "string" ? a : JSON.stringify(a, null, 2)))
          .join(" ");
        logEl.textContent += line + "\n";
        logEl.scrollTop = logEl.scrollHeight;
      }

      // Models (Realtime-capable)
      const MODELS = [
        "gpt-realtime",
        "gpt-realtime-mini",
        "gpt-4o-realtime-preview",
        "gpt-4o-mini-realtime-preview",
      ];

      // Voices (Realtime docs + announced realtime-only voices)
      const VOICES = [
        "marin",
        "cedar",
        "alloy",
        "ash",
        "ballad",
        "coral",
        "echo",
        "sage",
        "shimmer",
        "verse",
      ];

      for (const m of MODELS) {
        const opt = document.createElement("option");
        opt.value = m;
        opt.textContent = m;
        modelSelect.appendChild(opt);
      }
      for (const v of VOICES) {
        const opt = document.createElement("option");
        opt.value = v;
        opt.textContent = v;
        voiceSelect.appendChild(opt);
      }
      modelSelect.value = "gpt-realtime";
      voiceSelect.value = "marin";

      let pc = null;
      let localStream = null;
      let dc = null;

      async function connect() {
        if (pc) return;

        const model = modelSelect.value;
        const voice = voiceSelect.value;

        log("ðŸ”Œ Connecting...", { model, voice });

        pc = new RTCPeerConnection();

        pc.ontrack = (e) => {
          log("ðŸŽ§ Remote track received");
          remoteAudio.srcObject = e.streams[0];
        };

        pc.onconnectionstatechange = () => {
          log("ðŸ” PC state:", pc.connectionState);
        };

        // DataChannel (Ø§Ø®ØªÙŠØ§Ø±ÙŠ Ù„Ø¥Ø±Ø³Ø§Ù„ Ø£Ø­Ø¯Ø§Ø« / Ù†ØµÙˆØµ)
        dc = pc.createDataChannel("oai-events");
        dc.onopen = () => {
          log("ðŸ“¨ DataChannel open");
          sendFirstBtn.disabled = false;
        };
        dc.onmessage = (ev) => {
          // ÙƒØ«ÙŠØ± events Ø±Ø­ ØªØ¬ÙŠÙƒ â€” Ø®ÙÙ‘Ù Ø§Ù„Ù„ÙˆØ¬ Ø¥Ø°Ø§ Ø¨Ø¯Ùƒ
          try {
            const msg = JSON.parse(ev.data);
            if (msg?.type?.includes("error")) log("âŒ event:", msg);
            // log("event:", msg);
          } catch {
            // log("raw:", ev.data);
          }
        };

        // mic
        localStream = await navigator.mediaDevices.getUserMedia({
          audio: true,
        });
        for (const track of localStream.getTracks()) {
          pc.addTrack(track, localStream);
        }
        log("ðŸŽ¤ Microphone connected");

        // Offer -> send SDP to backend -> get answer SDP
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        const url = `/session?model=${encodeURIComponent(
          model
        )}&voice=${encodeURIComponent(voice)}`;

        const r = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/sdp" },
          body: offer.sdp,
        });

        if (!r.ok) {
          const err = await r.text();
          throw new Error("SDP exchange failed: " + err);
        }

        const answerSdp = await r.text();
        await pc.setRemoteDescription({ type: "answer", sdp: answerSdp });

        log("âœ… Connected (SDP set). Speak nowâ€¦");

        connectBtn.disabled = true;
        disconnectBtn.disabled = false;
      }

      function disconnect() {
        try {
          sendFirstBtn.disabled = true;

          if (dc) {
            dc.close();
            dc = null;
          }
          if (pc) {
            pc.close();
            pc = null;
          }

          if (localStream) {
            localStream.getTracks().forEach((t) => t.stop());
            localStream = null;
          }
          remoteAudio.srcObject = null;

          connectBtn.disabled = false;
          disconnectBtn.disabled = true;

          log("ðŸ›‘ Disconnected");
        } catch (e) {
          log("âŒ Disconnect error:", e);
        }
      }

      function sendFirstMessage() {
        if (!dc || dc.readyState !== "open") {
          log("âš ï¸ DataChannel not open yet");
          return;
        }
        const text = (firstMsgEl.value || "").trim();
        if (!text) return;

        // Realtime event flow: conversation.item.create Ø«Ù… response.create :contentReference[oaicite:6]{index=6}
        const item = {
          type: "conversation.item.create",
          item: {
            type: "message",
            role: "user",
            content: [{ type: "input_text", text }],
          },
        };
        const resp = {
          type: "response.create",
          response: {
            modalities: ["audio", "text"],
          },
        };

        dc.send(JSON.stringify(item));
        dc.send(JSON.stringify(resp));
        log("âž¡ï¸ First message sent.");
      }

      connectBtn.onclick = async () => {
        try {
          await connect();
        } catch (e) {
          log("âŒ Error:", e.message || e);
          disconnect();
        }
      };

      disconnectBtn.onclick = () => disconnect();
      sendFirstBtn.onclick = () => sendFirstMessage();
    </script>
  </body>
</html>
